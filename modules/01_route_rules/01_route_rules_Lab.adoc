:noaudio:
:scrollbar:
:data-uri:
:toc2:
:linkattrs:

= Route Rules Lab

== Overview

There are two microservices in this lab and they are chained together in the following sequence:

`gateway -> catalog`

In this lab you'll dynamically alter routing between the services using Istio intelligent routing.

== Goals

In this lab, you will learn how to:

* Deploy microservice applications to OpenShift
* Inject sidecar proxies into applications which form a service mesh
* Configure a service mesh to dynamically route and shape traffic to and from services

== Environment Variables

Before getting started, you'll want to open a terminal window and set the following environment variables that will be used throughout the duration of this lab.

-----
######  Instructor will provide the values to these environment variables #######

$ export REGION=<provided by your instructor>
$ export GUID=<provided by your instructor>
$ export OCP_PASSWD=<provided by your instructor>

#  Using above variables, copy & paste the following in same terminal #

$ export OCP_USERNAME=user$GUID
$ export OCP_GATEWAY_PROJECT=$OCP_USERNAME-coolstore-gateway
$ export OCP_CATALOG_PROJECT=$OCP_USERNAME-coolstore-catalog
-----

== Deploy Catalog service version 1 (`v1`)

Istio introduces the concept of a service version, which is a finer-grained way to subdivide
service instances by versions (`v1`, `v2`) or environment (`staging`, `prod`). These variants are not
necessarily different API versions: they could be iterative changes to the same service, deployed
in different environments (prod, staging, dev, etc.). Common scenarios where this is used include
A/B testing or canary rollouts. Istio’s https://istio.io/docs/concepts/traffic-management/rules-configuration.html[traffic routing rules, window="_blank"] can refer to service versions to
provide additional control over traffic between services.

. Deploy the catalog `v1` pod with its sidecar.
+
[source,text]
----
oc create -n ${ISTIO_LAB_PROJECT} -f ${ISTIO_LAB_HOME}/src/catalog/src/main/kubernetes/Deployment.yml
oc create -n ${ISTIO_LAB_PROJECT} -f ${ISTIO_LAB_HOME}/src/catalog/src/main/kubernetes/Service.yml
----
+
Since the catalog service is at the end of our service chain (`gateway -> catalog`),
it is not exposed to the outside world.

. Wait for it to completely roll out and receive a `deployment xxxxxx successfully rolled out` result:
+
[source,text]
----
oc rollout status -w deployment/catalog-v1
----
+
NOTE: The tag "v1" at the end of the deployment is important. We will be creating a v2 version of
catalog later in this lab. Having both a v1 and v2 version of the catalog
code will allow us to exercise some interesting aspects of Istio's capabilities.

. Test the customer service again (which will call the preference service which in turn calls
the catalog service). Now that it's all deployed, it should work:
+
[source,text]
----
curl ${GATEWAY_SERVICE_URL}
----

. You should see: `TODO: catalog json data`

== Deploy Catalog service version 2 (`v2`)

We can experiment with Istio routing rules by deploying a second version of the catalog
service.

. Deploy Catalog service version 2 
+
[source,text]
----
oc create -n ${ISTIO_LAB_PROJECT} -f ${ISTIO_LAB_HOME}/src/catalog/src/main/kubernetes/Deployment-v2.yml
----

. You can see both versions of the catalog pods running using `oc get pods`:
+
[source,text]
----
oc get pods -l app=catalog

NAME                                 READY     STATUS    RESTARTS   AGE
catalog-v1-60483540-9snd9     2/2       Running   0          12m
catalog-v2-2815683430-vpx4p   2/2       Running   0          15s
----
+
By default, Istio will round-robin incoming requests to the Catalog _Service_
so that both `v1` and `v2` pods get equal amounts of traffic:

. Send requests to the catalog service
+
[source,text]
----
for i in $(seq 10); do
  curl ${GATEWAY_SERVICE_URL}
done
----

Approximately half of the requests above go to `v1` and the other half to `v2`.

The default Kubernetes/OpenShift behavior is to round-robin load-balance across all
available pods behind a single Service. 

. Add another replica of `v2`:
+
[source,text]
----
oc scale --replicas=2 deployment/catalog-v2
----

. Now, you will see double the number of requests to `v2` than for `v1`:
+
[source,text]
----
for i in $(seq 10); do
  curl ${GATEWAY_SERVICE_URL}
done
----

. Go back to 1 copy:
+
[source,text]
----
oc scale --replicas=1 deployment/catalog-v2
----

== Send all traffic to `catalog:v2`

_Route rules_ control how requests are routed within an Istio service mesh.
Route rules provide:

* **Timeouts**
* **Bounded retries** with timeout budgets and variable jitter between retries
* **Limits** on number of concurrent connections and requests to upstream services
* **Active (periodic) health checks** on each member of the load balancing pool
* **Fine-grained circuit breakers** (passive health checks) – applied per instance in the load balancing pool

Requests can be routed based on the source and destination, HTTP header fields, and weights associated with individual service versions. For example, a route rule could route requests to different versions of a service.

In addition to the usual OpenShift object types like `BuildConfig`, `DeploymentConfig`,
`Service` and `Route`,
you also have new object types installed as part of Istio like `RouteRule`. Adding
these objects to the running
OpenShift cluster is how you configure routing rules for Istio.

. Route all traffic to `v2`:
+
[source,text]
----
oc create -f ${ISTIO_LAB_HOME}/src/istiofiles/route-rule-catalog-v2.yml -n ${ISTIO_LAB_PROJECT}
----

. Inspect the rule:
+
[source,text]
----
oc get routerule/catalog-default -o yaml
----

. Access the `customer` service 10 times - all requests should end up talking to
`catalog:v2`:
+
[source,text]
----
for i in $(seq 10); do
  curl ${GATEWAY_SERVICE_URL}
done
----

== Send all traffic to `catalog:v1`

. Now let's move everyone to `v1`:
+
[source,text]
----
oc replace -f ${ISTIO_LAB_HOME}/src/istiofiles/route-rule-catalog-v1.yml -n ${ISTIO_LAB_PROJECT}
----
+
NOTE: We use `oc replace` instead of `oc create` since we are overlaying the previous rule

. Run the test again:
+
[source,text]
----
for i in $(seq 10); do
  curl ${GATEWAY_SERVICE_URL}
done
----
+
Notice how all requests now to go `v1`.

Now let's go back to the start, and remove the rules to get back to default round-robin distribution
of requests.

. Remove route rules
+
[source,text]
----
oc delete -f ${ISTIO_LAB_HOME}/src/istiofiles/route-rule-catalog-v1.yml -n ${ISTIO_LAB_PROJECT}
----

. And test again:
+
[source,text]
----
for i in $(seq 10); do
  curl ${GATEWAY_SERVICE_URL}
done
----
+
Traffic should be equally split once again.

== Use a Canary Deployment to slowly rollout `v2`

To start the process, let's send 10% of the users to the `v2` version, to do a canary test:

+
[source,text]
----
oc create -f ${ISTIO_LAB_HOME}/src/istiofiles/route-rule-catalog-v1_and_v2.yml -n ${ISTIO_LAB_PROJECT}
----

Inspect the rule:

+
[source,text]
----
oc get routerule/catalog-v1-v2 -o yaml
----

You can see the use of the `weight` of each route to control the distribution of traffic.

Now let's send in 10 requests:

+
[source,text]
----
for i in $(seq 10); do
  curl ${GATEWAY_SERVICE_URL}
done
----

You should see only 1 request to `v2`, and 9 requests (90%) to `v1`. In reality you may get
2 requests as our sample size is low, but if you invoked
it 10 million times you should get approximately 1 million requests to `v2`.

Now let's move it to a 75/25 split:

+
[source,text]
----
oc replace -f ${ISTIO_LAB_HOME}/src/istiofiles/route-rule-catalog-v1_and_v2_75_25.yml -n ${ISTIO_LAB_PROJECT}
----

And issue 10 more requests:

+
[source,text]
----
for i in $(seq 10); do
  curl ${GATEWAY_SERVICE_URL}
done
----

Now you should see 2 or 3 requests (~25%) going to `v2`. This process can be continued (and automated), slowly migrating
traffic over to the new version as it proves its worth in production over time.

Let's remove the route rules before moving on:

+
[source,text]
----
oc delete routerule --all -n ${ISTIO_LAB_PROJECT}
----

== Congratulations!

In this lab you learned how to deploy microservices to form a _service mesh_ using Istio.
You also learned how to do traffic shaping and routing using _Route Rules_ which instruct
the Istio sidecar proxies to distribute traffic according to specified policy.

# References

* https://openshift.com[Red Hat OpenShift, window="_blank"]
* https://learn.openshift.com/servicemesh[Learn Istio on OpenShift, window="_blank"]
* https://istio.io[Istio Homepage, window="_blank"]